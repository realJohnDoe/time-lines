<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>YAML Timeline Stacked Bars</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col items-center p-4">
  <h1 class="text-2xl font-bold mb-4">YAML Timeline Stacked Bars</h1>
  <textarea id="yaml-input" rows="8" class="w-full max-w-xl p-2 border rounded mb-4" placeholder="Paste your YAML here..."></textarea>
  <button id="render-btn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Render Timeline</button>
  <div id="timeline" class="w-full max-w-3xl mt-8"></div>

  <!-- js-yaml CDN -->
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script>
    // Helper: parse YYYY or YYYY-MM to Date
    function parseDate(str) {
      if (!str) return null;
      str = String(str); // Ensure str is a string
      const parts = str.split('-');
      if (parts.length === 1) return new Date(Number(parts[0]), 0, 1);
      if (parts.length === 2) return new Date(Number(parts[0]), Number(parts[1]) - 1, 1);
      return new Date(str);
    }
    // Helper: format date as YYYY-MM or YYYY
    function formatDate(date) {
      if (!date) return '';
      const y = date.getFullYear();
      const m = date.getMonth() + 1;
      return m === 1 ? `${y}` : `${y}-${String(m).padStart(2, '0')}`;
    }

    // Assign stacking levels: younger topics on top, falling to lowest available non-overlapping row
    function assignLevels(topics) {
      // Sort by start date ascending (oldest first)
      topics.sort((a, b) => a.startDate - b.startDate);
      const levels = [];
      for (const topic of topics) {
        let lvl = 0;
        // Find the lowest level where this topic doesn't overlap
        while (true) {
          const conflict = levels[lvl]?.some(
            t => !(topic.endDate <= t.startDate || topic.startDate >= t.endDate)
          );
          if (!conflict) break;
          lvl++;
        }
        if (!levels[lvl]) levels[lvl] = [];
        levels[lvl].push(topic);
        topic.level = lvl;
      }
      // For rendering: reverse so youngest (latest start) is on top
      return topics.sort((a, b) => b.level - a.level || b.startDate - a.startDate);
    }

    // Render timeline
    function renderTimeline(topics, minDate, maxDate) {
      const barHeight = 36;
      const barGap = 8;
      const maxLevel = Math.max(...topics.map(t => t.level));
      const totalHeight = (maxLevel + 1) * (barHeight + barGap) + 32;
      const timelineWidth = 800;
      // Build year ticks (every year between minDate and maxDate)
      const years = [];
      for (let y = minDate.getFullYear(); y <= maxDate.getFullYear(); y++) years.push(y);

      // Compute positions
      function dateToX(date) {
        return ((date - minDate) / (maxDate - minDate)) * (timelineWidth - 80) + 60;
      }

      return `
        <div class="relative bg-white rounded shadow p-6 overflow-x-auto" style="height:${totalHeight}px; min-width:${timelineWidth}px">
          <!-- Year Ticks -->
          <div class="absolute left-0 top-0 w-full h-6 flex items-end text-xs text-gray-400">
            ${years.map(year => {
              const x = dateToX(new Date(year, 0, 1));
              return `<div style="position:absolute;left:${x}px;top:0;height:100%;width:1px;" class="border-l border-gray-200">
                <div style="position:absolute;left:-12px;top:12px;width:40px">${year}</div>
              </div>`;
            }).join('')}
          </div>
          <!-- Bars -->
          ${topics.map(topic => {
            const x1 = dateToX(topic.startDate);
            const x2 = dateToX(topic.endDate);
            // INVERT the stacking:
            const y = (maxLevel - topic.level) * (barHeight + barGap) + 32;
            const color = topic.tags?.includes('people') ? 'bg-blue-400' :
                          topic.tags?.includes('location') ? 'bg-green-400' : 'bg-gray-400';
            return `
              <div class="absolute flex items-center shadow-sm ${color} rounded text-white text-sm px-4 py-2 cursor-pointer hover:opacity-90"
                   style="left:${x1}px; top:${y}px; width:${Math.max(30, x2-x1)}px; height:${barHeight-8}px; z-index:10"
                   title="${topic.name} (${formatDate(topic.startDate)} → ${formatDate(topic.endDate)})">
                <span class="font-semibold">${topic.name}</span>
                <span class="ml-2 text-xs text-white/80">(${formatDate(topic.startDate)} → ${formatDate(topic.endDate)})</span>
                ${topic.tags?.map(tag => `<span class="ml-2 bg-white/20 rounded px-2 py-0.5 text-xs">${tag}</span>`).join('')}
              </div>
            `;
          }).join('')}
        </div>
      `;
    }

    document.getElementById('render-btn').onclick = function() {
      const yamlText = document.getElementById('yaml-input').value;
      let data;
      try {
        data = jsyaml.load(yamlText);
      } catch (e) {
        document.getElementById('timeline').innerHTML =
          `<div class="text-red-600">YAML Parse Error: ${e.message}</div>`;
        return;
      }
      if (!data || !Array.isArray(data.topics)) {
        document.getElementById('timeline').innerHTML =
          `<div class="text-red-600">No topics found in YAML.</div>`;
        return;
      }
      // Parse dates and prepare topics
      const topics = data.topics.map(t => ({
        ...t,
        startDate: parseDate(t.start),
        endDate: parseDate(t.end)
      })).filter(t => t.startDate && t.endDate);
      if (!topics.length) {
        document.getElementById('timeline').innerHTML =
          `<div class="text-red-600">No valid topics with start and end dates.</div>`;
        return;
      }
      // Find min/max dates for axis
      const minDate = new Date(Math.min(...topics.map(t => t.startDate)));
      const maxDate = new Date(Math.max(...topics.map(t => t.endDate)));
      // Assign stacking levels
      assignLevels(topics);
      // Render
      document.getElementById('timeline').innerHTML = renderTimeline(topics, minDate, maxDate);
    };

    // Example YAML for convenience
    document.getElementById('yaml-input').value = `topics:
  - name: person a
    start: 2011-07
    end: 2015-09
    tags:
      - people
  - name: location 1
    start: 2005
    end: 2018
    tags:
      - location
  - name: project x
    start: 2014-01
    end: 2016-06
    tags:
      - project
  - name: person b
    start: 2015-01
    end: 2017-03
    tags:
      - people
`;
  </script>
</body>
</html>
